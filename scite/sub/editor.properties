## Setting view.whitespace to 1 makes SciTE start up with whitespace visible.
## Setting view.indentation.whitespace to 0 hides visible whitespace inside indentation.
## Setting view.indentation.whitespace to 1 makes indentation whitespace visible
## Setting view.indentation.whitespace to 2 makes indentation whitespace only visible
view.whitespace=1
view.indentation.whitespace=2

## Setting view.indentation.guides to 1 displays dotted vertical lines within indentation white space every indent.size columns.
## Setting view.indentation.examine to 1 to display guides within real indentation whitespace only, 2 according to the next non-empty line (good for Python) or 3 according to both the next and previous non-empty lines (good for most languages).
## Setting highlight.indentation.guides to 1 highlights the indentation guide associated with a brace when that brace is highlighted.
view.indentation.guides=1
#view.indentation.examine
#view.indentation.examine.filepattern
highlight.indentation.guides=1

## Setting this to 1 makes SciTE display the characters that make up line ends. This looks similar to (CR), (LF), or (CR)(LF). This is useful when using files created on another operating system with software that is picky about line ends.
#view.eol

## When set to 1, all occurrences of the selected word are highlighted with the colour defined by highlight.current.word.colour. By default, this option is disabled. (See indicators.alpha and indicators.under)
highlight.current.word=1

## If the option highlight.current.word.by.style is set, then only words with the same style are highlighted (e.g. if you select this word in a comment, then only occurrences of words in comments are selected).
highlight.current.word.by.style=1


## Set whether all carets blink. 0 means only the main caret blinks. Default is 1.
caret.additional.blinks=0

## Sets the rate at which the caret blinks. The value is the time in milliseconds that the caret is visible before it is switched to invisible. It then stays invisible for the same period before appearing again. A value of 0 stops the caret from blinking.
caret.period=0

## Sets the width of the caret in pixels. Only values of 1, 2, or 3 work.
caret.width=3


## Determines whether the caret can be moved into virtual space, that is, beyond the last character on a line. Set to 1 to allow virtual space when making a rectangular selection, 2 to allow the arrow keys or a mouse click to move the caret into virtual space, and 3 to allow both. 4 may be added to prevent left arrow from wrapping to previous line.
#virtual.space

## If slop is set, we can define a slop value: width for xslop, lines for yslop.
## This value defines an unwanted zone (UZ) where the caret is... unwanted.
## This zone is defined as a number of pixels near the vertical margins, and as a number of lines near the horizontal margins.
## By keeping the caret away from the edges, it is seen within its context, so it is likely that the identifier that the caret is on can be completely seen, and that the current line is seen with some of the lines following it which are often dependent on that line.
##
## If strict is set, the policy is enforced... strictly.
## The caret is centred on the display if slop is not set, and cannot go in the UZ if slop is set.
##
## If jumps is set, the display is moved more energetically so the caret can move in the same direction longer before the policy is applied again.
## '3UZ' notation is used to indicate three time the size of the UZ as a distance to the margin.
##
## If even is not set, instead of having symmetrical UZs, the left and bottom UZs are extended up to right and top UZs respectively.
## This way, we favour the displaying of useful information: the beginning of lines, where most code reside, and the lines after the caret, e.g., the body of a function.
##
## See the table below to see how these settings interact.
## Default: xslop, yslop, xeven, yeven=1, width=50, all others = 0.
#caret.policy.xslop
#caret.policy.width
#caret.policy.xstrict
#caret.policy.xeven
#caret.policy.xjumps
#
#caret.policy.yslop
#caret.policy.lines
#caret.policy.ystrict
#caret.policy.yeven
#caret.policy.yjumps

## Determines how the display area is determined after a Go to command or equivalent such as a Find or Next Message. Options are similar to caret.policy.*.
#visible.policy.strict
#visible.policy.slop
#visible.policy.lines

## Indicates long lines. The default edge.mode, 0, does not indicate long lines. An edge.mode of 1 uses a vertical line to indicate the specified column and an edge.mode of 2 changes the background colour of characters beyond that column. For proportional fonts, an edge.mode of 2 is more useful than 1.
#edge.mode=2
edge.mode=1
edge.column=80
#edge.column=120

## Sets the character to use to indicate control characters. If not set, control characters are shown as mnemonics.
#control.char.symbol


## To see error messages interspersed with the source code, set error.inline=1.
## Different visual styles are used for different severities: style.error.0 is the default; style.error.1 for warnings; style.error.2 for errors; and style.error.3 for fatal errors. The severity of a message is inferred from finding the text "warning", "error", or "fatal" in the message.
#error.inline
#style.error.0
#style.error.1
#style.error.2
#style.error.3


## If set, the indicators are drawn under text or over (by default, it is over).
## Will be overridden by specific indicator definitions such as find.mark.indicator.
#indicators.under

## Flags to display markers at end and begin of wrapped lines for visual identify them. Set to 0 to not display markers (default). Set to 1 to display markers at end of wrapped lines, to 2 to display markers at begin of wrapped lines and to 3 to display markers at begin and end.
wrap.visual.flags=1

## Flags to set the location of the display markers (if enabled) near to text or near to border. Set to 0 to have begin and end markers near to border (default). Set to 1 to have end markers near text, to 2 to have begin markers near text and to 3 to have all markers near text.
#wrap.visual.flags.location

## Wrapped sublines can be indented in various ways relative to the initial subline. Default mode 0 indents sublines to the left of window plus wrap.visual.startindent. Mode 1 aligns sublines to the first subline. Mode 2 aligns sublines to the first subline plus one more level of indentation.
# wrap.indent.mode

## Sets the indention of continued wrapped lines to better visually identify the wrapping. Default is 0 (no indention). Note if wrap.visual.flags is 2 or 3 (begin marker displayed) the line is indented at least 1, even if wrap.visual.startindent is still 0.
#wrap.visual.startindent


## Sets the size of a tab as a multiple of the size of a space character in the style of the default style definition. The indent size is the size to use when performing automatic indentation and may be different from the tab size. Many people use a tab size of 8 but 4 character indentation. When creating indentation, use.tabs determines whether the indentation is made up purely from space characters or from a mix of tabs and spaces using as many tabs as possible. 
## The global tabsize, indent.size, and use.tabs properties can be overridden for files that match a pattern by using the file pattern forms: 
## indent.size.*.pas=3
## If indent.auto is set then indent.size and use.tabs are set according to the contents of the opened document.
## The properties file settings apply to newly opened files but remain constant once the file is open unless changed using the Change Indentation Settings dialog.
## If tab.indents is set then pressing tab within indentation whitespace indents by indent.size rather than inserting a tab character. If backspace.unindents then pressing backspace within indentation whitespace unindents by indent.size rather than deleting the character before the caret.
tabsize=4
#tab.size.filepattern
indent.size=4
#indent.size.filepattern
use.tabs=1
#use.tabs.filepattern
indent.auto=1
tab.indents=1
backspace.unindents=1




## Determines the look of automatic indentation. Automatic indentation is turned on with indent.automatic=1. To indent a brace line after a compound statement start set indent.opening=1, likewise for the terminating brace. So with both set to 0:
## if (c)
## {
##     s;
## }
## And with both set to 1:
## if (c)
##     {
##     s;
##     }
## Automatic indentation may be changed to simply repeat the indentation of the previous line for some files with indent.maintain.filepattern=1 which overrides the other language specific settings.
indent.automatic=1
#indent.opening
#indent.closing
#indent.maintain.filepattern


# default.file.ext	Defines the language mode used before the file has a name. For example, if default.file.ext=.py, then when the New command is used to create a new file then Python syntax styling is used.

# word.characters.filepattern	Defines which characters can be parts of words. The default value here is all the alphabetic and numeric characters and the underscore which is a reasonable value for languages such as C++.

# whitespace.characters.filepattern	Defines which characters are considered whitespace. The default value is that initially set up by Scintilla, which is space and all chars less than 0x20. Setting this property allows you to force Scintilla to consider other characters as whitespace (e.g. punctuation) during such activities as cursor navigation (ctrl+left/right).


##This property defines which words are to be styled in a particular substyle, in a similar way to keywords. For example, to use the first substyle of identifiers (11) for the C++ standard library identifiers "std", "map", "string", and "vector":
## substylewords.11.1.$(file.patterns.cpp)=std map string vector
#substylewords.mainstyle.substyle.filepattern


## Brace highlighting is a feature that shows the range of a brace when the caret is positioned immediately after it. It is especially useful when complex nested braces are used. The characters '(', ')', '[', ']', '{', and '}' are considered braces. The feature defaults to off (because it slows cursor movement) unless braces.check is set to 1. If braces.sloppy is set to 1 then if there is no brace before the caret then the character after the caret is checked. The highlighting is performed by displaying the braces in style number 34 or in style number 35 if there is no matching brace. While this is a full style, to avoid partial display of the braces, it is best to make this style differ from the standard style of braces only in foreground and background colour. Only braces with style set to braces.lexer.style (which defaults to 0) are candidates for brace match highlighting.
#braces.check
#braces.sloppy
#style.lexer.34
#style.lexer.35
#braces.lexer.style

