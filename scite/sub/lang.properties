## For XML and HTML, setting this property to 1 will make tags match in a case sensitive way which is the expected behaviour for XML and XHTML.
html.tags.case.sensitive=1

## lexer.asm.comment.delimiter	Character used for COMMENT directive's delimiter, replacing the standard "~".
## lexer.baan.styling.within.preprocessor	For Baan code, determines whether all preprocessor code is styled in the preprocessor style (0, the default) or only from the initial # to the end of the command word(1).

## Set to 0 to disallow the '$' character in identifiers with the cpp lexer.
#lexer.cpp.allow.dollars

## Set to 1 to enable highlighting of back-quoted raw strings .
lexer.cpp.backquoted.strings=1

## Set to 1 to enable highlighting of back-quoted raw strings .
lexer.cpp.escape.sequence=1

## Set to 1 to enable highlighting of hash-quoted strings.
#lexer.cpp.hashquoted.strings

## Set to 1 to interpret #if/#else/#endif to grey out code that is not active.
#lexer.cpp.track.preprocessor

## Set to 1 to enable highlighting of triple-quoted strings.
#lexer.cpp.triplequoted.strings

## Set to 1 to update preprocessor definitions when #define found.
#lexer.cpp.update.preprocessor

## Set to 1 to allow verbatim strings to contain escape sequences.
#lexer.cpp.verbatim.strings.allow.escapes

## Set to 1 for HSS (.hss)
#lexer.css.hss.language

## Set to 1 for Less CSS (.less)
lexer.css.less.language=1

## Set to 1 for Sassy CSS (.scss)
lexer.css.scss.language=1

## Set to 1 to enable the django template language.
#lexer.html.django

## Set to 1 to enable the mako template language.
#lexer.html.mako

## Set to 1 to enable highlighting of line/block comments in JSON
#lexer.json.allow.comments

## Set to 1 to enable highlighting of escape sequences in strings
lexer.json.escape.sequence=1

## For properties files, set to 0 to style all lines that start with whitespace in the default style. This is not suitable for SciTE .properties files which use indentation for flow control but can be used for RFC2822 text where indentation is used for continuation lines.
#lexer.props.allow.initial.spaces

## lexer.python.keywords2.no.sub.identifiers	When enabled, it will not style keywords2 items that are used as a sub-identifier. Example: when set, will not highlight "foo.open" when "open" is a keywords2 item.
## lexer.python.literals.binary	Set to 0 to not recognise Python 3 binary and octal literals: 0b1011 0o712.
## lexer.python.strings.b	Set to 0 to not recognise Python 3 bytes literals b"x".
## lexer.python.strings.over.newline	Set to 1 to allow strings to span newline characters.
## lexer.python.strings.u	Set to 0 to not recognise Python Unicode literals u"x" as used before Python 3.
## lexer.rust.fold.at.else	This option enables Rust folding on a "} else {" line of an if statement.

# lexer.errorlist.escape.sequences	Set to 1 to interpret escape sequences.

## For lines in the output pane that are matches from Find in Files or GCC-style diagnostics, style the path and line number separately from the rest of the line with style 21 used for the rest of the line. This allows matched text to be more easily distinguished from its location.
#lexer.errorlist.value.separate

# lexer.flagship.styling.within.preprocessor	For Harbour code, determines whether all preprocessor code is styled in the preprocessor style (0) or only from the initial # to the end of the command word(1, the default). It also determines how to present text, dump, and disabled code.
# lexer.haskell.allow.hash	Set to 0 to disallow the '#' character at the end of identifiers and literals with the haskell lexer (GHC -XMagicHash extension)
# lexer.haskell.allow.questionmark	Set to 1 to allow the '?' character at the start of identifiers with the haskell lexer (GHC & Hugs -XImplicitParams extension)
# lexer.haskell.allow.quotes	Set to 0 to disable highlighting of Template Haskell name quotations and promoted constructors (GHC -XTemplateHaskell and -XDataKinds extensions)
# lexer.haskell.cpp	Set to 0 to disable C-preprocessor highlighting (-XCPP extension)
# lexer.haskell.import.safe	Set to 0 to disallow "safe" keyword in imports (GHC -XSafe, -XTrustworthy, -XUnsafe extensions)


## Set to 1 to colourise recognized words with dots (recommended for Oracle PL/SQL objects).
#lexer.sql.allow.dotted.word

## If "lexer.sql.numbersign.comment" property is set to 0 a line beginning with '#' will not be a comment.
#lexer.sql.numbersign.comment

# lexer.verilog.allupperkeywords	Set to 1 to style identifiers that are all uppercase as documentation keyword.
# lexer.verilog.fold.preprocessor.else	This option enables folding on `else and `elsif preprocessor directives.
# lexer.verilog.portstyling	Set to 1 to style input, output, and inout ports differently from regular keywords.
# lexer.verilog.track.preprocessor	Set to 1 to interpret `if/`else/`endif to grey out code that is not active.
# lexer.verilog.update.preprocessor	Set to 1 to update preprocessor definitions when `define, `undef, or `undefineall found.
# lexer.xml.allow.scripts	Set to 0 to disable scripts in XML.

## Enables backslash as an escape character in SQL.
#sql.backslash.escapes

# styling.within.preprocessor	For C++ code, determines whether all preprocessor code is styled in the preprocessor style (0, the default) or only from the initial # to the end of the command word(1).
# tab.timmy.whinge.level	For Python code, checks whether indenting is consistent. The default, 0 turns off indentation checking, 1 checks whether each line is potentially inconsistent with the previous line, 2 checks whether any space characters occur before a tab character in the indentation, 3 checks whether any spaces are in the indentation, and 4 checks for any tab characters in the indentation. 1 is a good level to use.


# comment.block.lexer
# comment.block.at.line.start.lexer
# comment.stream.start.lexer
# comment.stream.end.lexer
# comment.box.start.lexer
# comment.box.middle.lexer
# comment.box.end.lexer	These settings are for the comment commands in the Edit menu and are defined separately for each lexer. Not all languages support both stream and block comments.
# Block comments are comments that start with a particular string and continue until the end of line. The comment.block property sets the string to be inserted or deleted at the start of the selected lines when the Block Comment or Uncomment command is performed. To make this command perform sensibly over a range of text that already contains comments and other code, the string can be defined to contain a character such as '~' that is not used in real comments.
# Set comment.block.at.line.start to "1" to place block comment symbols at the start of the lines, instead of just before the first non-blank character of the lines.
# Stream comments start with a particular string and end with another particular string and may continue over line ends. These are defined with comment.stream.start and comment.stream.end. 
# Box comments are a form of stream comment that takes several lines and uses different strings for the start, end and other lines in the range. These are defined with comment.box.start, comment.box.middle and comment.box.end.

# preprocessor.symbol.filepattern
# preprocessor.start.filepattern
# preprocessor.middle.filepattern
# preprocessor.end.filepattern	These settings make the preprocessor conditional movement and selection commands work. The character that defines preprocessor lines is defined by preprocessor.symbol. The preprocessor keywords that make up the start (if), middle (else), and end (endif) of preprocessor conditionals are defined by the other three properties. There may be multiple values for each of these, as, for example, C uses "if", "ifdef", and "ifndef" to begin preprocessor conditionals.

# lexer.filepattern	A lexer splits a file up into syntactic pieces. SciTE can then display these pieces in different visual styles. Many lexers are included in SciTE for popular programming languages such as Python, Java, C/C++, JavaScript and VB. Often several file extensions (.cpp, .cc, .h) can map to one language (C++) and hence one lexer. These settings associate a file name with a lexer.
# The lexers included in SciTE are written in C++ and compiled into the SciTE executable. Lexers can also be written as a Lua script or as a Lua LPeg lexer using scintillua.

# shbang.command	On Unix, command files often have no extension and instead specify the interpreter to use for the file in an initial line that starts with "#!". When the lexer can not be otherwise determined and the file starts with "#!", the initial line is split up into words and each word is prepended with "shbang.". If a property with this name exists then it is treated as the extension of the file. For example, shbang.python=py will be triggered by an initial line #!/usr/bin/env python so the file will be treated as Python.

# lexerpath.filepattern	Specifies the path to an external lexer module that will be loaded into Scintilla.


# keywords.filepattern
# keywords2.filepattern
# keywords3.filepattern
# keywords4.filepattern
# keywords5.filepattern
# keywords6.filepattern
# keywords7.filepattern
# keywords8.filepattern
# keywords9.filepattern
# keywordclass.lexer	Most of the lexers differentiate between names and keywords and use the keywords variables to do so. To avoid repeating the keyword list for each file extension, where several file extensions are used for one language, a keywordclass variable is defined in the distributed properties file although this is just a convention. Some lexers define a second set of keywords which will be displayed in a different style to the first set of keywords. This is used in the HTML lexer to display JavaScript keywords in a different style to HTML tags and attributes.
# Keywords can be prefix based so ^GTK_ will treat all words that start with GTK_ as keywords.



## Each of these settings starts with a style number and then a set of words or characters that define how to recognise that feature. If there is a second space in the setting then it is a set of words, otherwise a set of characters. The set of keywords used to indicate the start of a compound statement is defined in statement.indent. For example:
## statement.indent.$(file.patterns.cpp)=5 if else while
## says that for C++ the words "if", "else", and "while" in keyword style, 5, start compound statements which leads to the next line being indented if no other factors affect it. However, if a statement end is found on the same line then the next line is not indented. For C++ the statement end is the semicolon in the operator style, so this is defined:
## statement.end.$(file.patterns.cpp)=10 ;
## The number of lines looked at to determine indentation can be set with statement.lookback. This can be used either to bound the amount of time spent on this task or to specify that only the last line be examined for indentation.
## The block.start and block.end properties define the language elements used to bracket groups of statements. In C++ these are '{' and '}'.
#statement.indent.filepattern
#statement.end.filepattern
#statement.lookback.filepattern
#block.start.filepattern
#block.end.filepattern

## For Python, automatically indent by one level if the previous line ended in a ':' ignoring comments and whitespace. Otherwise use the same indentation as the previous line. This property overrides other indentation settings.
#indent.python.colon

## Chooses the behaviour of the Home and Shift+Home keys. 1, the default is like Visual C++ moving the caret to the end of the line indentation unless already there, in which case it moves to the start of the line. 0 moves to the start of the line.
#vc.home.key

## Set a value to be included in the Language menu when using the default value for menu.language. For example, *language.ruby=Ruby|rb|F9| adds a "Ruby" item to the Language menu which maps to the "rb" file extension and can be chosen with the F9 key. More than one language may be defined in one variable. There must be a multiple of 3 '|' characters in the setting.
#*language.name

